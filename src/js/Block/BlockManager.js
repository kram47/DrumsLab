/**
*
* @file
*     Block/BlockManager.js
* @description
*     Manager for blocks view of chops
        -> Manage the list of chop
        -> Manage the front part such as positions, colors etc
* @author
*     marc charton
*
*/

/**
 * @module BlockManager
 */
var BlockManager = (function ()
{

    "use strict";

    // -- -- M O D U L E   S E T T I N G S -- --

    // Module Configuration
    var config = {
        container : {
            name : 'canvas_container',
            width : 600,
            height : 1200
        },
        note : {
            yNoteSize : 20,
            xBeatSizeBase : 100,
        },
        noteTypes : [
            {
                "name" : "played",
                "notation" : 1,
                "color" : "90-#2980b9-#3498db",
                "class" : "score-played"
            },
            {
                "name" : "ghost",
                "notation" : 2,
                "color" : "90-#bdc3c7-#ecf0f1",
                "class" : "score-ghost"
            },
            {
                "name" : "accent",
                "notation" : 3,
                "color" : "90-#c0392b-#e74c3c",
                "class" : "score-accent"
            }
        ]
    };

    // Module name
    var _name = "BlockManager";

    // Module Method Exposition
    var blockManager = {
        config : config,
        init : init,
        drawRectangle : drawRectangle,
        drawNote : drawNote,
        drawBeat : drawBeat,
        drawBar : drawBar,
    };


    // -- -- P R I V A T E   P R O P E R T I E S -- --

    // RaphaelJS main object
    var _paper_;
    var _chopList;

    // Log d'un message avec le nom du module
    function log (message) {
        console.log("["+_name+"] " + message);
    };


    // -- -- P U B L I C   M E T H O D S -- --

    /*
        Initialisation du module
     */
    function init () {
        log("Initialisation");

        _paper_ = new Raphael(document.getElementById(config.container.name), config.container.width, config.container.height);
    };

    /**
     * Dessine un rectangle
     * @param  {int} xStart - x position of rectangle to draw (from up-left corner)
     * @param  {int} yStart - y position of rectangle to draw (from up-left corner)
     * @param  {int} xSize - x size (width) of rectangle to draw
     * @param  {int} ySize - y size (height) of rectangle to draw
     * @return {Object} rectangle - Rectangle generated by RaphaelJS
     */
    function drawRectangle(xStart, yStart, xSize, ySize) {
        var rectangle = _paper_.rect(xStart, yStart, xSize, ySize);
        return rectangle;
    };

    /**
     * Dessine une note
     *     Prend en compte la taille standard d'une note
     *     Définit la longueur de la note en fonction de sa valeur temporelle
     * @param  {Note} note - The note to draw
     * @param  {int} xStart - x position of note to draw (from up-left corner)
     * @param  {int} yStart - y position of note to draw (from up-left corner)
     * @return {Object} xSize - Longueur de la note en pixel
     */
    function drawNote(note, xStart, yStart) {
        var xSize = config.note.xBeatSizeBase * note.beatDuration;
        return drawRectangle(xStart, yStart, xSize, config.note.yNoteSize);
    };

    /**
     * Dessine un temps
     * @param {Note|Array} notes - An array with the beat's notes
     * @param {Object} signature - Signature of bar in which is the beat
     */
    function drawBeat(notes, signature, xPosition = 0, yPosition = 0) {

        if (! (notes instanceof Array))
            throw { type : "type",  message : "'notes' should be an array."};

        var totalDuration = 0.0;
        notes.map(note => {
            totalDuration += note.beatDuration;
        });

        log(`totalDuration of array([${notes.map(x => x.time).join(',')}])= ${totalDuration}`);

        // TODO : Adapter le calcul du temps à la signature rythmique
        // il ne faut pas forcément qu'un bloc fasse 1. (ex: en 7/8 ce sera 0.5)
        if (totalDuration != 1)
            log("désolé mon gars mais le temps n'est pas de la bonne taille");
        else {
            log("ok mon temps fait bien la bonne longueur");

            let xStart = xPosition,
                yStart = yPosition;
            var noteRectangleList = [];

            notes.map(note => {
                var noteRectangle = drawNote(note, xStart, yStart);
                xStart += noteRectangle[0].width.baseVal.value;
                noteRectangleList.push(noteRectangle);
            });

            return noteRectangleList;
        }
    };


    /**
     * Draw a bar
     * @param {Bar} bar - The bar with all beats to draw
     * @param {Bar} bar - The bar with all beats to draw
     * @param {Bar} bar - The bar with all beats to draw
     */
    function drawBar(bar, xPosition = 0, yPosition = 0) {

        if (! (bar instanceof Bar))
            throw { type : "type",  message : "'bar' should be a Bar object."};

        let beatXOffset = 10;
        var beatRectangleList = [];

        // Drawing each beat one by one
        bar.beats.map((beat) => {
            console.log(beat);

            // We add an offset between each beat
            xPosition += beatXOffset;

            // Draw the current beat
            var noteRectangleList = drawBeat(beat, bar.signature, xPosition, yPosition);

            // We add the size of each note block in the beat to the offset
            noteRectangleList.map((noteRectangle) => {
                xPosition += noteRectangle[0].width.baseVal.value;
            });

            // we keep the list of note rectangle in a list
            beatRectangleList.push(noteRectangleList);
        });

    };

    /**
     * Add a chop to the internal chop list
     * The list isn't drawn at this time
     * @param {Chop} chop - The chop to add to the list
     */
    function addChop(chop){
        // TODO : add the chop to the list
        // TODO : compute the graphic position of each voice
    }

    /**
     * Draw the chop list on the screen
     */
    function drawChopList()
    {
        // TODO : draw every voice of every chop
    }

    return blockManager;

})();
